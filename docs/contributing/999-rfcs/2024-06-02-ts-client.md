---
title: "Exported TypeScript Clients Across Wing Applications"
description: Exported TypeScript Clients Across Wing Applications
---

# Exported TypeScript Clients Across Wing Applications

- **Author(s)**: @MarkMcCulloh
- **Submission Date**: 2024-06-02

## Use Case

Given some infrastructure defined in wing by platform engineers, we want to provide a way for application developers in the same organization to interact with that infrastructure in a type-safe way from their own codebases without dealing with wing or infrastructure themselves.

As a platform engineer I'd like to use wing to create the preflight infrastructure for developers in my organization, and then produce client libraries in TypeScript for accessing that infrastructure within other pieces of code.
Imagine for example that the application developers write TypeScript running in containers in their own repo, and that repo's code is already being automatically deployed with GitOps via ArgoCD or other means.

As an application developer I'd like to consume the TypeScript package published by the platform team and write application code that interacts with these resources (using whichever methods or permissions have been granted by the platform team). If I'm running my TypeScript code / container locally I expect the wing clients to connect to the wing simulator and interact with the simulated resources, and when my code is deployed to the AWS I expect the clients to connect to the real cloud resources.

## Proposal

The `typescript` module has a `Client` class used to create a client. When this is instantiated, `wing compile` will produce a publishable JavaScript npm package with TypeScript type declarations.

```wing
bring clients;

let client = new typescript.Client(
  name: "@acme/infra-client",
  // version: "0.0.0",
  // outdir: join(@dirname, "dist"),
);
```

To lift a resource into the client to make it accessible to consumers, add a `@lift` expression:

```wing
bring cloud;

let bucket = new cloud.Bucket();

let client = new typescript.Client(
  name: "@acme/infra-client",
  lifts: @lift({ bucket: [put] }),
);
```

In order to access the lifted objects at runtime, the TypeScript client needs to know how it should obtain the initialization data for instantiating the inflight clients (e.g. resource ARNs and other preflight state). This information is stored in client.context in preflight.
When the client is used later (inflight), the environment variable `WING_CONTEXT` is expected to the same value previously stored in client.context.

The context is just a string value (base64 encoded JSON), so you can store it in any way that is convenient for your deployment process.

For example, it could be stored in a bucket:

```wing
bring cloud;
bring clients;
bring fs;

let client = new typescript.Client(
  name: "@acme/infra-client",
);

// The deployer of the client host will need to retrieve/link this data later
let clientContext = new cloud.Bucket();
clientContext.addObject("ctx", client.context)
```

Regardless of the approach used to resolve the context, using the generated client will work the same way:

```ts
import { Client } from "@acme/infra-client";

// Will use the environment variable WING_CONTEXT to resolve the context
const client = new Client();

// Optionally, you can pass the context directly to bypass the environment variable
// const client = new Client({ context: "..." });

await client.bucket.put("key", "value");
```

The client code is the same as the generated javascript as if it were used within wing itself!

## Implementation Details

### Client context data

The client context data is a JSON object that contains all the necessary information to connect to the resources.
It's read through the environment variable `WING_CONTEXT` and is expected to be a base64 encoded.

For now, the only information that needs to be stored are environment variables.
This corresponds to the only API available on `IInflightHost`, which is `addEnvironment`, which is how these values are added:

```json
{
  "version": "1",
  "env": {
    "BUCKET_HANDLE_a107cec5": "abcxyz"
  }
}
```

The client itself is effectively a proxy of an unseen/unavailable `IInflightHost`, so any expressivity that interface has must be handled by the client.

### Permissions

The client does not directly/automatically handle permissions needed for the arbitrary host it could run on.
There is no expectation that the deployer of the host is also using wing so there is no shared system to transfer permission knowledge.

For example, when using

```wing
let client = new typescript.Client(
  name: "@acme/infra-client",
  lifts: @lift({ bucket: [put] }),
);
```

it would be helpful to retrieve the necessary information about the `bucket` and the `put` operation.

If you're using terraform and deploying to AWS, you will need the bucket name and the correspond IAM policy.
There is no abstract API available to store/retrieve this information currently as this is handled only by target-specific subtypes of `IInflightHost`.

To keep this simple, we can provide and a helper API in the shared aws module (and other platforms, as needed) to generate the necessary policies by exposing the lift information (i.e. the `std.LiftQualificationsContainer`) from the client.

```wing
bring aws;

let policies = aws.generatePolicyStatements(client.lifts);
```

With these, one can generate a policy document to attach to a role/user to be used by the client's host.

If you're using the simulator, this problem is (currently) more difficult.
The simulator is centralized and will have no knowledge of the future clients that will be using it.
The simulator has no API to add new permissions after the simulator has started and the scope of that feels too large for this RFC.

As an MVP, the simulator can be configured to ignore permissions via `wing.toml`.
Even though this is unsafe and cause cause local/cloud differences, wing is intentionally not claiming ownership of the client's host environment.

### Type generation with `@lift`

Wing's compiler has type information available for use, but only before preflight execution occurs.
This makes an API like the following not feasible to implement using logic similar to the existing `extern` or `@inflight`:

```wing
client.lift("bucket", bucket, ["put"]);
```

While executing preflight, the knowledge about the type of the `bucket` instance is lost, so generating the actual client code will have no way to reference it.

This RFC proposes changing the existing `lift` syntax as a way to capture the necessary type information during preflight.
An important feature of this syntax is that it's entirely statically analyzable, so anything we need to do with it can be done before-preflight.
The existing `lift` syntax is currently intended to be used only inside inflights to explicitly lift preflight data into the defined scope:

```wing
let b1 = new cloud.Bucket();
inflight () => {
  let var b = b1;
  lift { b: [put] } {
    b.put("key", "value");
  }
}
```

With some changes, with syntax could also be used as a way to create a preflight container for lifted data.

```wing
let b = new cloud.Bucket();
let lifts = @lift({ b: [put] });
//  ^^^^^ is a std.LiftQualificationsContainer
```

This is very similar to the `lift` mechanism in `@wingcloud/framework`

```ts
const b = new cloud.Bucket(app, "Bucket");
const lifts = lift({ bucket }).grant({ bucket: ["put"] });
```

In the [RFC for explicit lift qualifications](https://github.com/winglang/wing/blob/main/docs/contributing/999-rfcs/2024-03-14-explicit-lift-qualification.md), there is a mention of a `std.LiftQualificationsContainer`.

If this data structure is augmented to also include type information, it could be used to generate the client during preflight.
The resulting data would look very similar to the existing _liftMap, with the addition of the link to the `.d.ts` generated by the compiler for the aggregate type information.

### Client Contents

The client package will contain the following:

- package.json

Minimal package.json with the name and version. For MVP, the package will not have any dependencies because the client code is self-contained.

- index.js

Exports the `Client` class. In this class constructor, the context is read from the environment variable `WING_CONTEXT` (or constructor arg) and is used to set the environment variables for the current process. Each lifted object will then be instantiated which utilizes the existing `_toInflight` logic and will consume all the necessary environment variables.

(Future Improvements: The lifted clients could be lazily instantiated?)

- index.d.ts

Exports the `Client` class, with fields for each lifted object. Each field will reference a type from `lifts.d.ts`.

- lifts.d.ts

The resulting types from `@lift`

## Example Usage

### Kubernetes

```wing
bring cloud;

let bucket = new cloud.Bucket();

let client = new typescript.Client(
  name: "@acme/infra-client",
  lifts: @lift({ bucket: [put] }),
);
```

When generating a client for use in a Kubernetes pod, ConfigMaps are a standard mechanism for storing configuration data.
If the kubernetes manifests for the cluster is managed in wing, the ConfigMap can be directly created to store the context data:

```wing
new k8s.ConfigMap(
  name: "client-ctx",
  data: {
    "ctx": client.context,
  },
);
```

Otherwise, the data can be mapped similarly to the other methods like SSM or buckets.
If you're using terraform/cfn, an output can be created with the context be managed manually after deployment.

```wing
// cdktf
new cdktf.Output(
  name: "ClientContext",
  value: client.context,
);

/// aws-cdk-lib
new awscdk.CFNOutput(
  name: "ClientContext",
  value: client.context,
);
```

Once a ConfigMap is created, when the pod running the client is created it can be mounted as an environment variable:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
  spec:
    containers:
      - name: app
        image: app-image
        env:
          - name: WING_CONTEXT
            valueFrom:
              configMapKeyRef:
                name: ctx
                key: ctx
```

### AWS Lambda

```wing
bring cloud;
bring clients;
bring util;
bring "@cdktf/provider-aws" as aws;
bring "cdktf" as cdktf;

let bucket = new cloud.Bucket() as "shared";

let client = new typescript.Client(
  name: "@acme/infra-client",
  lifts: @lift({ bucket: [put] }),
);

// Set up an SSM parameter to store the context
new aws.ssmParameter.SsmParameter(
  name: "/acme/infra-client/context",
  type: "String",
  value: client.context,
);
```

For an AWS Lambda deployment, the SSM parameter can be directly mapped to the environment variable.

For local development, the owners of the central infrastructure can provide a script to lookup the SSM parameter and add the environment variable to the lambda either via an env or whatever deployment process being used.
