---
title: "Exported TypeScript Clients Across Wing Applications"
description: Exported TypeScript Clients Across Wing Applications
---

# Exported TypeScript Clients Across Wing Applications

- **Author(s)**: @MarkMcCulloh
- **Submission Date**: 2024-06-02

## Use Case

Given some infrastructure defined in wing by platform engineers, we want to provide a way for application developers in the same organization to interact with that infrastructure in a type-safe way from their own codebases without dealing with wing or infrastructure themselves.

As a platform engineer I'd like to use wing to create the preflight infrastructure for developers in my organization, and then produce client libraries in TypeScript for accessing that infrastructure within other pieces of code.
Imagine for example that the application developers write TypeScript running in containers in their own repo, and that repo's code is already being automatically deployed with GitOps via ArgoCD or other means.

As an application developer I'd like to consume the TypeScript package published by the platform team and write application code that interacts with these resources (using whichever methods or permissions have been granted by the platform team). If I'm running my TypeScript code / container locally I expect the wing clients to connect to the wing simulator and interact with the simulated resources, and when my code is deployed to the AWS I expect the clients to connect to the real cloud resources.

## Proposal

The `clients` module has a `TypeScript` class used to create a client. When this is instantiated, `wing compile` will produce a publishable JavaScript npm package with TypeScript type declarations.

```wing
bring clients;

let client = new clients.TypeScript(
  name: "@acme/infra-client",
  // version: "0.0.0",
  // outdir: join(@dirname, "dist"),
);
```

To lift a resource into the client to make it accessible to consumers, add a `lift` expression:

```wing
bring cloud;

let bucket = new cloud.Bucket();

client.lift(lift { bucket: [put] });
```

In order to access the bucket, the client needs to know it should resolve the relevent information (e.g. bucket name or handle).
This information is stored in client.context, so we need to way to both store and resolve this information.
For example, we can store/retrieve the context from a file:

```wing
bring cloud;
bring clients;
bring fs;

let client = new clients.TypeScript(
  name: "@acme/infra-client",
  contextResolver: inflight () => {
    return fs.readJson("/var/run/wing-client-context.json");
  },
);

// The consumer of the client will need to retrieve/link this data after deployment
let clientContext = new cloud.Bucket() as "ctx";
clientContext.addObject("ctx", Json.stringify(client.context))
```

If the runtime cost is acceptable, the context can even be directly resolved directly from the bucket during the client's runtime:

```wing
bring cloud;
bring clients;

let clientContext = new cloud.Bucket() as "ctx";
let client = new clients.TypeScript(
  name: "@acme/infra-client",
  contextResolver: inflight () => {
    return Json.parse(clientContext.get("ctx"));
  },
);

// hydrates the context during deployment
clientContext.addObject("ctx", Json.stringify(client.context))
```

In cases where reading from the filesystem is difficult and the overhead or a runtime lookup is too high, the context can be passed in via an environment variable:

```wing
bring cloud;
bring clients;
bring util;

let bucket = new cloud.Bucket() as "shared";

let client = new clients.TypeScript(
  name: "@acme/infra-client",
  contextResolver: inflight () => {
    let ctxRaw = util.getEnv("WING_CLIENT_CONTEXT");
    let ctxDecoded = util.fromBase64(ctxRaw);
    return Json.parse(ctxDecoded);
  },
);

client.add(lift { bucket: [put] });
```

Regardless of the approach used to resolve the context, using the generated client will work the same way:

```ts
import { Client } from "@acme/infra-client";

// performs the context resolution
const client = new Client();

await client.bucket.put("key", "value");
```

The client code is the same as the generated javascript as if it were used within wing itself!

## Implementation Details

### Client context data

The client context data is a JSON object that contains all the necessary information to connect to the resources.
For now, the only information that needs to be stored are environment variables.
This corresponds to the only API available on `IInflightHost`, which is `addEnvironment`, which is how these values are added:

```json
{
  "version": "1",
  "env": {
    "BUCKET_HANDLE_a107cec5": "abcxyz"
  }
}
```

The client itself is effectively a proxy of an unseen/unavailable `IInflightHost`, so any expressivity that interface has must be handled by the client.

### Permissions

The client does not directly/automatically handle permissions needed for the arbitrary host it could run on.
There is no expectation that the deployer of the host is also using wing so there is no shared system to transfer permission knowledge.

For example, when using

```wing
client.lift(lift { bucket: [put] });
```

it would be helpful to retrieve the necessary information about the `bucket` and the `put` operation.

If you're using terraform and deploying to AWS, you will need the bucket name and the correspond IAM policy.
There is no abstract API available to store/retrieve this information currently as this is handled only by target-specific subtypes of `IInflightHost`.

To keep this simple, we can provide and a helper API in the shared aws module (and other platforms, as needed) to generate the necessary policies by exposing the lift information (i.e. the `_liftMap`) from the client.

```wing
bring aws;

let policies = aws.generatePolicyStatements(client.lifts);
```

With these, one can generate a policy document to attach to a role/user to be used by the client's host.

If you're using the simulator, this problem is (currently) more difficult.
The simulator is centralized and will have no knowledge of the future clients that will be using it.
The simulator has no API to add new permissions after the simulator has started and the scope of that feels too large for this RFC.

As an MVP, the simulator can be configured to ignore permissions via `wing.toml`.
Even though this is unsafe and cause cause local/cloud differences, wing is intentionally not claiming ownership of the client's host environment.

### Type generation with `lift`

Wing's compiler has type information available for use, but only before preflight execution occurs.
This makes an API like the following not feasible to implement using logic similar to the existing `extern` or `@inflight`:

```wing
client.lift("bucket", bucket, ["put"]);
```

While executing preflight, the knowledge about the type of the `bucket` instance is lost, so generating the actual client code will have no way to reference it.

This RFC proposes changing the existing `lift` syntax as a way to capture the necessary type information during preflight.
An important feature of this syntax is that it's entirely statically analyzable, so anything we need to do with it can be done before-preflight.
The existing `lift` syntax is currently intended to be used only inside inflights to explicitly lift preflight data into the defined scope:

```wing
let b1 = new cloud.Bucket();
inflight () => {
  let var b = b1;
  lift { b: [put] } {
    b.put("key", "value");
  }
}
```

With some changes, with syntax could also be used as a way to create a preflight container for lifted data.

```wing
let b = new cloud.Bucket();
let lifts = lift { b: [put] };
//  ^^^^^ is a std.LiftQualificationsContainer
```

This is very similar to the `lift` mechanism in `@wingcloud/framework`

```ts
const b = new cloud.Bucket(app, "Bucket");
const lifts = lift({ bucket }).grant({ bucket: ["put"] });
```

In the [RFC for explicit lift qualifications](https://github.com/winglang/wing/blob/main/docs/contributing/999-rfcs/2024-03-14-explicit-lift-qualification.md), there is a mention of a `std.LiftQualificationsContainer`.

If this data structure is augmented to also include type information, it could be used to generate the client during preflight.

```wing
let b = new cloud.Bucket();
client.add(lift { b: [put] });
```

An initial implementation of this can re-use the existing `.d.ts` generation, and the std.LiftQualificationsContainer can store a path to that generated file to be used as-is when generating the full client in preflight.

## Example Usage

### Kubernetes

When generating a client for use in a Kubernetes pod, ConfigMaps are a standard mechanism for storing configuration data.
To resolve the context, the ConfigMap would be mounted to the pod and the client would read the data from the mounted file:

```wing
let client = new clients.TypeScript(
  name: "@acme/infra-client",
  contextResolver: inflight () => {
    return fs.readJson("/var/run/client-ctx.json");
  },
);
```

If the kubernetes manifests for the cluster is managed in wing, the ConfigMap can be directly created to store the context data:

```wing
new k8s.ConfigMap(
  name: "client-ctx",
  data: client.context,
);
```

Otherwise, the data can be mapped similarly to the other methods like SSM or buckets.
If you're using terraform/cfn, an output can be created with the context be managed manually after deployment.

```wing
// cdktf
new cdktf.Output(
  name: "ClientContext",
  value: client.bindContext
);

/// aws-cdk-lib
new awscdk.CFNOutput(
  name: "ClientContext",
  value: client.bindContext
);
```

This could be used to create a user/role that is eventually usable within the k8s cluster as a service account.

### AWS Lambda

```wing
bring cloud;
bring clients;
bring util;
bring "@cdktf/provider-aws" as aws;
bring "cdktf" as cdktf;

let bucket = new cloud.Bucket() as "shared";

let client = new clients.TypeScript(
  name: "@acme/infra-client",
  contextResolver: inflight () => {
    let ctxRaw = util.getEnv("WING_CLIENT_CONTEXT");
    let ctxDecoded = util.fromBase64(ctxRaw);
    return Json.parse(ctxDecoded);
  },
);

client.add(lift { bucket: [put] });

// Set up an SSM parameter to store the context
let contextAsString = cdktf.Fn.base64encode(cdktf.Fn.jsonencode(client.context));
new aws.ssmParameter.SsmParameter(
  name: "/acme/infra-client/context",
  type: "String",
  value: contextAsString,
);
```

On the client side, the context is expected to be resolved by a base64-encoded environment variable.
For an AWS Lambda deployment, the SSM parameter can be directly mapped to the environment variable.

For local development, the owners of the central infrastructure can provide a script to lookup the SSM parameter and add the environment variable to the lambda either via an env or whatever deployment process being used.
