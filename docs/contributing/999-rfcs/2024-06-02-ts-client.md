---
title: "TypeScript Clients Across Wing Applications"
description: TypeScript Clients Across Wing Applications
---

# TypeScript Clients Across Wing Applications

- **Author(s)**: @MarkMcCulloh
- **Submission Date**: 2024-06-02

## Summary

Allow for the generation of TypeScript clients that can interact with wing-defined infrastructure.
Unlike `extern` or `@inflight`, the client is meant to be consumed by TypeScript applications rather than directly executed by Wing itself.

The goal of this document is to walk through the DX of this experience.

An important consideration for this discussion is allowing the generated client to reference resources defined from a separate wing application.
To facilitate this separation, it seems necessary to introduce a mechanism to export/import deployed data between Wing apps.
The rest of this proposal does it via `cloud.Outputs`, but that likely deserves its own RFC.

## Example Situation

Acme Co. has a platform team and several application teams. Their platform team manages Kubernetes clusters in AWS with additional AWS resources as needed.
Application teams write applications in TypeScript and deploy them to these shared Kubernetes clusters.
The centralized infrastructure definitions are written in Wing in their own repository.
The applications are written in TypeScript but also have Wing files for infrastructure/deployment.

To add a new application, the platform team needs to ensure that the application has the necessary permissions to interact with the shared resources. To do this, a kubernetes namespace and service account is created:

```wing
let namespace = cluster.createNamespace("app123");
let serviceAccount = cluster.createServiceAccount(
  namespace: namespace,
  name: "app123-svc",
);

serviceAccount.grantRead(sharedBucket);
```

Applications using that namespace and service account will now have access to the shared bucket.

To export this data to downstream applications, `cloud.Outputs` can be used:

```wing
let outputs = new cloud.Outputs();

// Can reference preflight data (tokens will be resolved)
outputs.add("namespace", namespace.name);
outputs.add("serviceAccount", serviceAccount.name);

// and inflight clients (includes the necessary information to interact with the resource for the given operations)
// (e.g. a bucket name, a URL, etc.)
outputs.lift("sharedBucket", sharedBucket, ["put"]);

// Create a Wing library
outputs.export(
  name: "@acme/core-infra",
);
```

This will create a centralized registry that can be imported elsewhere.
During deployment, this registry will be updated with the relevant information.
Additionally, it exports a wing library with all the necessary types and runtime code to look up that information.
This library is published to an internal registry for other teams.

After the central infrastructure is deployed, the application team can import the information into their own wing application:

```wing
bring "@acme/core-infra" as coreInfra;

let workload = new Workload(
  namespace: coreInfra.namespace,
  serviceAccount: coreInfra.serviceAccount,
  image: join(@dirname, "app"),
);
```

Now the application will have the necessary permissions to interact with the shared bucket.

However, we need to create a client for TypeScript to actually make use of these permissions.
The environment where the client will run needs to know where to resolve the bucket.
To do this, the client can attach to any inflight host. This takes care of preparing it for the client to run.
Luckily, the workload exposes this host for us:

```wing
let client = new TypeScriptClient(
  outdir: join(@dirname, ".wing"),
  host: workload.host,
);

// No need to specify the operations, we want all the ones available from this limited resource
client.lift("sharedBucket", coreInfra.sharedBucket);
```

After compilation, we can finally use this client in the TypeScript application:

```ts
// src/index.ts
import { sharedBucket } from "../.wing";

await sharedBucket.put("key", "value");
```

To run this locally, `wing it` is used for both the root infrastructure and then the application.

### Implementation Thoughts

#### Skipping cloud.Outputs?

Without `cloud.Outputs` this proposal would be much simpler.
The TypeScript client could be generated in the root infrastructure project and published as is.
Then, something would need to be manually done (or scripted) to ensure that the client can resolve the necessary resources.

This feels like extremely poor DX, to the point that it removes the value of using Wing in the first place.
So it felt more valuable to introduce `cloud.Outputs` to explore the DX of a more ideal solution.

#### Runtime types

This document assumes Wing will generate the winglib and the TypeScript client during preflight.
Type information is needed to do this correctly. Implementing any of this will require the compiler to store type information on/in preflight data.
